/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <hamsandwich>
#include <fvault>
#include <cstrike>
#include <fakemeta>
#include <engine>
#include <fun>
#include <xs>
#include <colorchat>
#include <amxmisc>
#include <camera_options>


#define PLUGIN "RPG Surf"
#define VERSION "0.01"
#define AUTHOR "ObjectX"
#define PREFIX "[Surf]"

/****************
	Suggestion:
	Fix trasnparent when dueling by giving a model to each player(?). In this case, what if some players do dueling together at the same time?
	Maybe set it to only 1 duel at a time? Gotta think.
*****************/

#define CONNECTED_FOR_KKS 0 // no need for this, how many players connected for knife points.

#define MAX_TIMES_SPARKLERS 5
#define MAX_LEVEL 45

#define DUEL_DELAY 30 // Don't spam duels, wait 30 seconds between each request.
#define DECLINE_TIMER 15 // Automatically Decline duels after DECLINE_TIMER seconds.


/* Comment this line for no debugging  */
//#define _DEBUG_CODE

#define TASK_ID 934279423 // for round end detection

#define STEAMID_AUTHORIZED "STEAM_0:0:35828728"



new bool:MuteLevelUpSound[ 33 ];
new bool:ShootingEffect[ 33 ] = { true, ... };
new bool:ReviveOnDeath[ 33 ];

new g_iSpriteExplosion;

/* ************************* */
/* Blocked Names Information */
/* ************************* */
enum _:BLOCKED_NAMES
{
	STEAMID_TO_ALLOW[ 35 ],
	szAllowedNames[ 32 ]
}

new CustomBlockedNamesSize;

new const szBlockedNames[ ] [ BLOCKED_NAMES ]  =
{
	{ "STEAM_0:0:35828728", "xpar" },
	{ "STEAM_0:0:35828728", "objectx" }
}

/* *********************** */
/* Custom Tags Information */
/* *********************** */
enum _:CHAT_TAGS_INFO 
{
	STEAMID[ 35 ],
	szTagName[ 21 ]
}

new CustomTagsSize;

new const ChatCustomTags[ ] [ CHAT_TAGS_INFO ] =
{
	{ "STEAM_0:0:35828728", "????" },
	{ "STEAM_0:1:70549078", "ObjectX's Student" }
}

/* ****************** */
/* Main Settings Menu */
/* ****************** */
enum _:SETTING_MENUS{
	LEVELUP_SETTINGS,
	SHOOTING_SETTINGS,
	SKILLS_SETTINGS
}

new szSettings[ SETTING_MENUS ] [ ] =
{
	"Levelup Settings",
	"Shooting Settings",
	"Skills Settings"
}


/* ********************* */
/* LevelUp Settings Menu */
/* ********************* */
enum _:SETTINGS_LEVELUP{
	VOLUME_INCREASE,
	VOLUME_DECREASE,
	PLAY_SOUND,
	STOP_SOUND,
	MUTE
}

new LevelUpSettings[ SETTINGS_LEVELUP ] [ ] =
{
	"Increase Volume",
	"Decrease Volume",
	"\yPlay Sound",
	"\dStop Sound",
	"\rLevelup Sound"
}

/* ***************************** */
/* Shooting Effect Settings Menu */
/* ***************************** */

enum _:SETTINGS_EFFECT_WEAPONS{
	SHOT_EFFECT
}

new szShootingEffects[ SETTINGS_EFFECT_WEAPONS ] [ ] =
{
	"Use Shot Effect"
}

/* ********************** */
/*  Skills Settings Menu  */
/* ********************** */

enum _:SETTINGS_SKILLS{
	SETTING_REVIVE_ON_DEATH
}

new szSkillsEffects[ SETTINGS_SKILLS ] [ ] =
{
	"Revive On Death"
}

enum _:KNIVES{
	NORMAL_KNIFE,
	ALIEN_KNIFE,
	DAGGER_KNIFE,
	TRANSPARENT_KNIFE,
	SHADOW_BLADE_KNIFE,
	ASSASIN_BLADE_KNIFE,
	LIGHTSABER_KNIFE,
	WOLVERINE_KNIFE
}
new const Float:WOLVERINE_HIT_RANGE = 100.0;

enum _:MENUS{
	LEVELS_MENU,
	UPGRADE_MENU,
	SKILLS_MENU,
	DUELER_MENU,
	BLOCK_MENU,
	CREDITS_SHOW,
	SETTINGS_MENU
}

enum _:SKILLS{
	ABILITY_BACK_TO_LIFE_CHANCE,
	ABILITY_EXTRA_EXPERIENCE,
	ABILITY_HP_REGENERATION,
	ABILITY_DUEL,
	ABILITY_CAMERA,
	ABILITY_TRAIL,
	ABILITY_LIFESTEAL_TWENTYPERCENT,
	ABILITY_KILL_HP_REGEN,
	ABILITY_NO_PAIN_SHOCK,
	ABILITY_WEAPON_GRABBER,
	ABILITY_KAMIKAZE
}

new const ExpOptions [ ] = { 0, 25, 50, 75, 100, 125, 150 }

new playersCount[ 33 ];

new gTitles[ ] [ ] =
{
	"Newbie",
	"Novice",
	"Rookie",
	"Beginner",
	"Talented",
	"Skilled",
	"Intermediate",
	"Skillful",
	"Seasoned",
	"Proficient",
	"Experienced",
	"Advanced",
	"Senior",
	"Expert",
	"Master"
}
new const MenuList[ MENUS ] [ ] = 	
{ 
	"Level Menu",
	"Knife Menu",
	"Skills Menu",
	"Duel Menu",
	"Block Duels",
	"\yPlugin Information",
	"Client Settings"
}
new const MenuNames[ MENUS ] [ ] = 
{
	"fnShowPersonLevel",
	"fnKnivesMenu",
	"fnSkillsMenu",
	"fnDuelMenu",
	"fnBlockDuelsMenu",
	"fnCredits",
	"fnSettingsMenu"
}

new Current_Level[ 33 ];
new Current_Exp[ 33 ];
new Knife_Kills[ 33 ];

new Float:userVolume[ 33 ] = 20.0;

// Duels
new bool:gBlocked[ 33 ] [ 33 ];
new gDuelers[ 33 ] ; // for duelers' IDs
new bool:duelActive[ 33 ];
new iKillsInDuel[ 33 ];
new iXPBet[ 33 ];
new delaySeconds[ 33 ];
new declineTimer[ 33 ] = DECLINE_TIMER;
new duelMenu[ 33 ];
new bool:DuelOptionChosen[ 33 ];
new duelIndex[ 33 ];

new const TASKID_REMOVE_DUEL_DELAY = 1461362;


// Skills


/*
SECOND CHANCE
*/
new bool:diedThisRound[ 33 ];

/*
HP REGENERATION
*/
new const HP_REGENERATION_TASKID = 5126832;
new bool:Regenerating[ 33 ];

/*
NO PAINS HOCK
*/

new bool:g_bRestoreVel
new Float:g_vecVel[3]
new g_fmPlayerPreThink
new g_fmPlayerPreThink_Post

/*
KAMIKAZE
*/
new const KAMIKAZE_TASKID = 1512536;
new const Float:KAMIKAZE_RANGE = 200.0;
new const KAMIKAZE_POWER = 3000;
new const PLAYERS_LOGGED_FOR_KAMIKAZE = 1; // in each team
new const KamikazeSound[ ] = "progamingsurf/Surf/kamikaze2.wav"
new bool:g_Kamikazed[ 33 ];




// Knife
new KnifeActive[ 33 ];
new knifeChosen[ 33 ];

new ModelsLocation[ 60 ];

new const KnifeList[ KNIVES ] [ ] = 	
{ 
	"Normal Knife",
	"Alien Knife",
	"Dark Dagger",
	"Transparent Knife",
	"Shadow Blade",
	"Assasin's Blade",
	"Dark Soul Sword",
	"Wolverine's Claws"
};
new const KnifeRequired[ KNIVES ] =
{ 
	-1,
	15,
	45,
	90,
	150,
	220,
	300,
	400
};
new const KnifeInformation[ KNIVES ] [ ] =
{
	"Knife Slash Damage: \y15^n\wKnife Stab Damage: \y65",
	"Knife Slash Damage: \y16^n\wKnife Stab Damage: \y66",
	"Knife Slash Damage: \y17^n\wKnife Stab Damage: \y67",
	"Knife Slash Damage: \y18^n\wKnife Stab Damage: \y68",
	"Knife Slash Damage: \y19^n\wKnife Stab Damage: \y69",
	"Knife Slash Damage: \y20^n\wKnife Stab Damage: \y70",
	"Knife Slash Damage: \y21^n\wKnife Stab Damage: \y71",
	"Knife Slash Damage: \y22^n\wKnife Stab Damage: \y72^n\r[ \wSpecial Effects \r]^n \w33% Cleave Damage for 100 Radius Units"
}

// Skills
new const LevelSkills[ SKILLS ] [ ] =
{
 	"Second Chance",
	"Extra Experience",
	"HP Regeneneration",
	"Duel Ability",
	"Camera Ability",
	"Trail Ability",
	"20% Lifesteal",
	"Kill HP Regeneration",
	"No Pain Shock",
	"Weapon Grabber",
	"Kamikaze"
}
new const LevelRequired[ SKILLS ] =
{
 	1,
	3,
	5,
	7,
	10,
	13,
	15,
	19,
	24,
	29,
	35
}
new const LevelDescription[ SKILLS ] [ ] = 	
{
	"You have a 20% chance of being revived on death",
	"You now have a 15% chance of receiving extra XP upon killing",
	"You'll be healed by 1HP every 5 seconds",
	"You can now be dueled by others and start dueling by yourself, type ^"/help^" or press M and you'll have an extra sub-menu",
	"type /cam to play in third person mode or in upside mode",
	"type ^"trail <color>^" and ^"trail < 1-12 >^" to have a trail following you, ^"trail off^" to disable",
	"Whenever you hit someone, you will convert 20% of the damage to your own hitpoints",
	"You'll be healed by 10% of your damage for any kill you get",
	"You'll not be slowed down on ground after being hit",
	"You are now able to pick up any weapon that is on the bottom of the map",
	"You can now bind ^"kamikaze^" to a key to activate the skill. eg: bind f kamikaze. Can only be used as last survivor in team."
}
new g_max_players;

new const g_vault_name[ ] = "SurfSave_Finalized";

new iTimeSparklers[ 33 ] = 0;

new iSprite;

new const LEVELS[ MAX_LEVEL ] =
{
	25, 
	75, 
	140,
	240,
	350,
	500,
	650,
	820,
	1000,
	1200,
	1400,
	1600,
	1800,
	2000,
	2200,
	2400,
	2700,
	3000,
	3300,
	3700,
	4100,
	4400,
	4700,
	5000,
	5500,
	6000,
	6500,
	7000,
	7500,
	8000,
	8500,
	9000,
	9500,
	10000
	11000
	12000
	13000
	14000
	15000
	16000
	17000
	18000
	19000
	20000
	21000
}

native has_fast_zoomed(index);

public plugin_natives()
{	
	register_library( "progamingsurf" );
	
	register_native( "get_level","_get_level" )
	
	register_native( "is_Dueling", "_is_Dueling" )
}

public _is_Dueling( iPlugin, iParams )
{
	if( iParams != 1 )
		return 0;
	
	new id = get_param( 1 );
	if( !id )
		return 0;
	
	return ( duelActive[ id ] ) ? true : false;
}

public _get_level( iPlugin, iParams )
{
	if( iParams != 1 )
		return PLUGIN_CONTINUE
	
	new id = get_param( 1 )
	if( !id )
		return PLUGIN_CONTINUE
		
	
	return Current_Level[ id ];
}

new SyncDuelHudMsg;

new SyncCreditsMsg;

new g_pcvar_mp_roundtime;

public plugin_init( ) {
	register_plugin( PLUGIN, VERSION, AUTHOR )
	
	register_clcmd( "say", "CmdSay" );
	
	g_pcvar_mp_roundtime = get_cvar_pointer("mp_roundtime")
	
	RegisterHam( Ham_Spawn, "player", "HamPlayerSpawn", 1 );
	RegisterHam( Ham_TakeDamage, "player", "Player_TakeDamage" );
	RegisterHam( Ham_TakeDamage, "player", "Player_TakeDamagePost" ,1);
	
	g_fmPlayerPreThink = register_forward(FM_PlayerPreThink, "onPlayerPreThink")
	g_fmPlayerPreThink_Post = register_forward(FM_PlayerPreThink, "onPlayerPreThink_Post", 1)
	
	register_forward(FM_GetGameDescription, "Change" );
	
	// Round End Detection
	register_logevent( "logevent_round_end", 2, "1=Round_End" );
	register_logevent("logevent_round_start", 2, "1=Round_Start")
	register_event("HLTV", "remove_existing_task", "a", "1=0", "2=0")
	
	register_clcmd("amx_addxp", "fnGiveXP", ADMIN_IMMUNITY, "- amx_addxp <username> <added_xp>" );
	register_clcmd("amx_addknifekills", "fnAddKKs", ADMIN_IMMUNITY, "- amx_addknifekills <username> <added_knifekills>" );
	register_clcmd("amx_setlevel", "fnSetLevel", ADMIN_IMMUNITY, "- amx_setlevel <username> <level>" );
	
	register_event( "DeathMsg", "EventDeathMsg", "a" );
	register_event( "CurWeapon", "event_CurrWeapon", "be", "1=1", "2=29" );
	
	register_clcmd( "say /level", "fnShowPersonLevel" );
	register_clcmd( "say_team /level", "fnShowPersonLevel" );
	register_clcmd( "say /xp", "fnShowPersonLevel" );
	register_clcmd( "say_team /xp", "fnShowPersonLevel" );
	
	register_clcmd( "say /knife", "fnKnivesMenu" );
	register_clcmd( "say_team /knife", "fnKnivesMenu" );
	
	register_clcmd( "say /skills", "fnSkillsMenu" );
	register_clcmd( "say_team /skills", "fnSkillsMenu" );
	
	register_clcmd( "say /help", "fnHelpMenu" );
	register_clcmd( "say_team /help", "fnHelpMenu" );
	register_clcmd( "chooseteam", "fnHelpMenu" );
	
	register_clcmd( "say /cam", "chooseview" )
	register_clcmd( "say_team /cam", "chooseview" )    
	register_clcmd( "say /camera", "chooseview" )
	register_clcmd( "say_team /camera", "chooseview" ) 
	
	register_clcmd( "kamikaze", "fnKamikaze" );
	
	register_clcmd( "checkduels", "fnCheckDuels" );
	
	RegisterHam( Ham_TraceAttack, "worldspawn", "fwDrawTrace" )
	
	
	register_message( get_user_msgid( "TextMsg" ), "hook_TextMsg" )
	
	SyncDuelHudMsg = CreateHudSyncObj( );
	
	SyncCreditsMsg = CreateHudSyncObj( );
	
	g_max_players = get_maxplayers( );
	
	set_task( 120.0, "printHelp", _, _, _, "b", _);
	
	register_forward( FM_AddToFullPack, "AddToFullPack", 1 );
	
	register_touch( "weaponbox", "worldspawn", "touchWorld" );
	register_touch( "weaponbox", "player", "touchPlayer" );
	
	register_touch( "player", "*", "touchKamikaze" );
	
	CustomTagsSize = sizeof( ChatCustomTags );
	CustomBlockedNamesSize = sizeof( szBlockedNames );
	
	register_forward( FM_ClientUserInfoChanged, "ClientUserInfoChanged" );
}

public fnKamikaze( index )
{
	if( is_user_alive( index ) )
	{
		if( Current_Level [ index ] >= LevelRequired[ ABILITY_KAMIKAZE ] )
		{
			if( g_Kamikazed[ index ] )
			{
				
				ColorChat( index, TEAM_COLOR, "%s ^1Kamikaze can only be used once a round!", PREFIX );
				return;
			}
			
			
			new tCount;
			new tCountAlive;
			new ctCount;
			new ctCountAlive;
			
			for( new i = 1 ; i <= g_max_players ;i ++ )
			{
				if( is_user_connected( i ) )
				{
					if( cs_get_user_team( i ) == CS_TEAM_T )
					{
						tCount++;
						if( is_user_alive( i ) )
						{
							tCountAlive++;
						}
					}
					else if( cs_get_user_team( i ) == CS_TEAM_CT )
					{
						ctCount++;
						if( is_user_alive( i ) )
						{
							ctCountAlive++;
						}
					}
				}
			}
			
			if( tCount < PLAYERS_LOGGED_FOR_KAMIKAZE  || ctCount < PLAYERS_LOGGED_FOR_KAMIKAZE)
			{
				ColorChat( index, TEAM_COLOR, "%s ^1There must be %d players in each team to use ^3kamikaze^1.", PREFIX, PLAYERS_LOGGED_FOR_KAMIKAZE );
				return;
			}
			
			new CsTeams:playerTeam;
			
			playerTeam = cs_get_user_team( index );
			
			if( (playerTeam == CS_TEAM_CT && ctCountAlive == 1) || (playerTeam == CS_TEAM_T && tCountAlive == 1) )
			{
				g_Kamikazed[ index ] = true;
				static Float:kamikazeTo[ 3 ];
				
				VelocityByAim( index, KAMIKAZE_POWER, kamikazeTo );
				
				set_hudmessage( 0, 255, 0, 0.04, 0.65, 2, 0.1, 1.0, 0.0, 1.5 )
				show_hudmessage( index, "You will explode in 3 seconds if you don't touch anything." )
				
				emit_sound( index, CHAN_STREAM, KamikazeSound, VOL_NORM, ATTN_NORM, 0, PITCH_NORM );
				
				set_task( 3.0, "fnExplodeKamikaze", index + KAMIKAZE_TASKID );
				
				entity_set_vector( index, EV_VEC_velocity, kamikazeTo );
			}
			else
			{
				ColorChat( index, TEAM_COLOR,"%s ^1You can only use ^3kamikaze^1 if you are the last survivor of your team!", PREFIX );
			}
			
		}
	}
}

public fnExplodeKamikaze( index )
{
	index -= KAMIKAZE_TASKID;
	if( is_user_alive( index ) )
	{
		new Float:origin[ 3 ];
		pev( index, pev_origin, origin );
		
		message_begin( MSG_BROADCAST ,SVC_TEMPENTITY );
		write_byte( TE_EXPLOSION );
		engfunc( EngFunc_WriteCoord, origin[ 0 ] )
		engfunc( EngFunc_WriteCoord, origin[ 1 ] )
		engfunc( EngFunc_WriteCoord, origin[ 2 ] )
		write_short( g_iSpriteExplosion );
		write_byte( 10 ); // scale in 0.1's
		write_byte( 10 ); // Framerate
		write_byte( 0 ); // flags
		message_end( );
		
		new iFakeEnt = create_entity( "grenade" );
		
		new ent = -1
		
		while( ( ent = find_ent_in_sphere( ent, origin, KAMIKAZE_RANGE) ) != 0 ) // finds entity index.
		{
			if( is_user_alive( ent ) )
			{
				static Float:fDistance;
				static Float:entityOrigin[ 3 ];
				pev( ent, pev_origin, entityOrigin );
					
				fDistance = get_distance_f( entityOrigin, origin ); // distance between suicider and victim.
				
				ExecuteHamB( Ham_TakeDamage, ent, iFakeEnt, index, floatabs(KAMIKAZE_RANGE - floatabs(fDistance)), 1<<24 ); // 1 << 24 == DMG_HEGRENADE
				ColorChat(0, GREEN, "Current: %2f-%2f=%2f", KAMIKAZE_RANGE,floatabs(fDistance), floatabs(KAMIKAZE_RANGE-fDistance));
			}
			
		}
	}
}

public touchKamikaze( suicider, victim )
{
	if( g_Kamikazed[ suicider ] && !diedThisRound[ suicider ] )
	{
		fnExplodeKamikaze( suicider + KAMIKAZE_TASKID );
	}
}

public fnCheckDuels( index )
{
	for( new i ; i < g_max_players ; i ++ )
	{
		if( duelActive[ i ] )
		{
			console_print( index, "%s is dueling %s with a score of %d to %d", fnGetName( i ), fnGetName( gDuelers[ i ] ), iKillsInDuel[ i ], iKillsInDuel[ gDuelers[ i ] ] );
		}
	}
}

public touchWorld( weaponbox, worldspawn )
{
	if( pev_valid( weaponbox ) )
	{
		float_weapon( weaponbox )
	}
}

public touchPlayer( weaponbox, id )
{
	if( pev_valid( weaponbox ) )
	{
		static Float:flOrigin[ 3 ];
		entity_get_vector( weaponbox, EV_VEC_origin, flOrigin );
		if( isTouchingWorldGround( flOrigin ) )
		{
			return ( Current_Level[ id ] < LevelRequired[ ABILITY_WEAPON_GRABBER ] );
		}
	}
	return 0;
}

public float_weapon( ent )
{
	if( pev_valid( ent ) )
	{
		static Float:flOrigin[ 3 ];
		entity_get_vector( ent, EV_VEC_origin, flOrigin );
		if( isTouchingWorldGround( flOrigin ) ) // Making sure its not in the mario room.
		{
			if( !( pev( ent, pev_flags ) & FL_INWATER ) ) // making sure its not in water.
			{
				entity_set_int( ent, EV_INT_movetype, MOVETYPE_TOSS );
				flOrigin [ 2 ] = -1750.0;
				entity_set_origin( ent, flOrigin );
			}
		}
	}
}

stock bool:isTouchingWorldGround( Float:entOrigin[ 3 ] )
{
	if( entOrigin[ 2 ] > -2000.0 && entOrigin[ 2 ] <= -1700.0 ) // Making sure its not in the mario room, should be <= so this can be used in touchPlayer too.
	{
		return true;
	}
	return false;
}

// Ent - Player who calls the forward.
// Host - The Entity that's about to update.
// Player - This will be 1 if Host is a player, otherwise 0.

public AddToFullPack( State, E, Ent, Host, hFlags, Player, pSet )
{
	if ( !is_user_alive( Ent )|| !is_user_alive ( Host ) || !duelActive[ Host ] || !duelActive[ Ent ] || duelIndex[ Host ] != Ent || duelIndex[ Ent ] != Host )
	{
		forward_return( 0 );
		return FMRES_SUPERCEDE;
	}
	
	set_es( State, ES_RenderFx, kRenderFxGlowShell );
	set_es( State, ES_RenderColor, { 255, 0 , 0 } );
	set_es( State, ES_RenderMode, kRenderTransAdd );
	set_es( State, ES_RenderAmt, 255 ); 
	
	return FMRES_SUPERCEDE;
}

public fwDrawTrace( ent, attacker, Float:damage, Float:direction[ 3 ], ptr, damage_type )
{
	if( !is_user_alive( attacker )  ||
	get_user_weapon( attacker ) == CSW_KNIFE || 
	get_user_weapon( attacker ) == CSW_HEGRENADE ||
	get_user_weapon( attacker ) == CSW_SMOKEGRENADE ||
	get_user_weapon( attacker ) == CSW_FLASHBANG ) 
		return 0;
		
	static iStart[ 3 ];
	get_user_origin( attacker, iStart, 0 )
	
	static Float:iEnd[ 3 ];
	get_tr2( ptr, TR_vecEndPos, iEnd );
	
	new timesToDoLoop;
	
	if( get_user_weapon( attacker ) == CSW_XM1014 || get_user_weapon( attacker ) == CSW_M3 )
	{
		timesToDoLoop = 5;
	}
	else timesToDoLoop = 1;
	
	if( ShootingEffect[ attacker ] )
	{
		for( new i ; i < timesToDoLoop  ; i ++ )
		{
			message_begin( MSG_BROADCAST, SVC_TEMPENTITY )
			write_byte( TE_TRACER )
			
			write_coord( iStart[ 0 ] )	// start position
			write_coord( iStart[ 1 ] )
			write_coord( iStart[ 2 ] )
			
			engfunc( EngFunc_WriteCoord, iEnd[ 0 ] );
			
			switch( random_num(0,1) )
			{
				case 0: iEnd[ 0 ] += random( 50 );
				case 1: iEnd[ 0 ] -= random( 50 );
			}
			
			engfunc( EngFunc_WriteCoord, iEnd[ 1 ] );
			
			switch( random_num(0,1) )
			{
				case 0: iEnd[ 1 ] += random( 50 );
				case 1: iEnd[ 1 ] -= random( 50 );
			}
			
			engfunc( EngFunc_WriteCoord, iEnd[ 2 ] );
			
			switch( random_num(0,1) )
			{
				case 0: iEnd[ 2 ] += random( 50 );
				case 1: iEnd[ 2 ] -= random( 50 );
			}
			
			message_end()
		}
	}
	return 1;
}

public plugin_cfg( )
{
	set_cvar_num( "sv_airaccelerate", 99999 );
	set_cvar_num( "sv_wateraccelerate", 99999 );
	set_cvar_num( "mp_freezetime", 1 );
	set_cvar_num( "mp_buytime", 999 );
	set_cvar_num( "mp_startmoney", 16000 );
	set_cvar_num( "mp_roundtime", 4 );
	set_cvar_num( "sv_stepsize", 18 );
	
	set_cvar_num( "sv_zmax", 12288 );
	
	set_cvar_num( "sv_alltalk", 1 );
	set_cvar_num( "sv_voiceenable", 1 );
	
	set_cvar_string( "sv_voicecodec", "voice_speex" );
	
	/* Change skybox every 30 minutes */
	set_cvar_num( "mp_timelimit", 30 );
	set_cvar_string( "amx_nextmap", "surf_ski_2" );
}

public fnCredits( index )
{	
	set_hudmessage( 0, 255, 255, 0.60, 0.60, 1, 0.05, 20.0, 0.5, 3.0, -1)
	ShowSyncHudMsg( index , SyncCreditsMsg, 
	"| Surf - By XpaR |^n\
	- - - - - - - - - - - - - - - - - - - - - - -^n\
	Type /help or press M to see the general menu.^n\
	The basic idea of this plugin is to kill enemies and gain XP in order to level up.^n\
	As you level up you gain skills. If you kill with a knife, \
	you might get a knife kill point. When you reach certain ^n\
	amounts of Knife kill points you unlock new knives^n\
	Each knife adds one damage total on a slash/stab."
	);
}

public Change() {      
	forward_return(FMV_STRING, PLUGIN);
	return FMRES_SUPERCEDE; 
}  

public fnSuicidePunishment( plr )
{
	if( duelActive[ plr ] )
	{
		iKillsInDuel[ gDuelers[ plr ] ]++;
		ColorChat( plr, TEAM_COLOR, "%s ^1You opponent has gotten another kill because you commit suicide with ^'kill^' command!", PREFIX );
		if( iKillsInDuel[ gDuelers[ plr ] ] >= 5 )
		{
			duelWin( gDuelers[ plr ], plr );
		}
	}
}

public chooseview( id ){
	if( Current_Level[ id ] >= LevelRequired[ ABILITY_CAMERA ] )
		set_camera( id );
	return 1;
}

public fnHelpMenu( plr )
{
	new Title[ 32 ] = "\ySurf - General Menu"
	
	new GeneralMenu = menu_create( Title, "general_handler" )
	new Item[ 50 ];
	new IntStr[ 5 ];
	new i = 0;
	for( ; i < MENUS ; i++ )
	{
		if( i == DUELER_MENU && Current_Level[ plr ] < LevelRequired[ ABILITY_DUEL ] )
			continue;
			
		Item="\w%s";
		format( Item, charsmax( Item ), Item, MenuList[ i ] );
		
		num_to_str( i, IntStr, charsmax( IntStr ) )
		menu_additem( GeneralMenu, Item, IntStr, 0 );
	}
	
	menu_setprop( GeneralMenu, MPROP_BACKNAME, "Back" );
	menu_setprop( GeneralMenu, MPROP_NEXTNAME, "Next" );
	//menu_additem(KnifeMenu,"Exit","MENU_EXIT");
	//menu_setprop(KnifeMenu, MPROP_PERPAGE, 7);
	menu_display( plr, GeneralMenu );
	//if( get_user_flags( plr ) & ADMIN_CHAT )
	//	return 1; // dont spam amx_help in console when using /help (flySlap.amxx)
	return 1;
}

public general_handler(id, GeneralMenu, item)
{
	
	if( item == MENU_EXIT ){
		menu_destroy( GeneralMenu )
		return PLUGIN_HANDLED	
	}
	
	new Data[ 7 ], Name[ 64 ];
	new Access, Callback;
	menu_item_getinfo( GeneralMenu, item, Access, Data, 5, Name, 63, Callback )
	
	new key = str_to_num( Data )
	
	if( key == DUELER_MENU)
	{
		if( !is_user_alive( id ) )
		{
			ColorChat( id, GREEN, "%s ^1You need to be alive to start a duel!", PREFIX );
			fnHelpMenu( id );
			return 0;
		}
		else if( delaySeconds[ id ] > 0 )
		{
			ColorChat( id, GREEN,"%s ^1You must wait another ^3%d ^1seconds before requesting another duel!",PREFIX, delaySeconds[ id ] );
			fnHelpMenu( id );
			return 0;
		}
		else if( duelActive[ id ] )
		{
			ColorChat( id, GREEN,"%s ^1You have already started a duel! you cant start another one!",PREFIX, delaySeconds[ id ] );
			fnHelpMenu( id );
			return 0;
		}
	}
	set_task( 0.1, MenuNames[ key ], id );
	return 0;
}

public fnSettingsMenu( plr )
{
	
	new Title[ 126 ] = "\ySurf - Settings Menu"
	new SettingsMenu = menu_create( Title, "Settings_handler" )
	
	new Item[ 70 ];
	new IntStr[ 3 ];
	
	
	new i;
	for( ; i < SETTING_MENUS - 1 ; i++ )
	{
		Item="%s";
		format( Item, charsmax( Item ) , Item, szSettings[ i ] );
		
		num_to_str( i, IntStr, charsmax( IntStr ) );
		
		menu_additem( SettingsMenu, Item, IntStr, 0 );
	}
	
	if( Current_Level[ plr ] >= LevelRequired[ ABILITY_BACK_TO_LIFE_CHANCE ] ) // If the user has any skills
	{
		Item="\w%s";
		format( Item, charsmax( Item ), Item, szSettings[ i ] );
		
		num_to_str( i, IntStr, charsmax( IntStr ) )
		menu_additem( SettingsMenu, Item, IntStr, 0 ); // Show him the skills option menu.
	}
	
	menu_setprop( SettingsMenu, MPROP_EXITNAME, "Back" );
	
	menu_display( plr, SettingsMenu );
}

public Settings_handler( id, SettingsMenu, item )
{
	
	if( item == MENU_EXIT ){
		menu_destroy( SettingsMenu )
		fnHelpMenu( id );
		return PLUGIN_HANDLED	
	}
	
	new Data[ 7 ], Name[ 64 ];
	new Access, Callback;
	menu_item_getinfo( SettingsMenu, item, Access, Data, 5, Name, 63, Callback )
	
	new key = str_to_num( Data )
	
	switch( key )
	{
		case LEVELUP_SETTINGS:
		{
			fnLevelUpSettings( id );
		}
		case SHOOTING_SETTINGS:
		{
			fnShootingSettings( id );
		}
		case SKILLS_SETTINGS:
		{
			fnSkillsSettings( id );
		}
	}
	
	return 0;
}

public fnLevelUpSettings( plr )
{
	new Title[ 126 ] = "\ySurf - Levelup Settings^n\rVolume: \y%0.1f%"
	format( Title, charsmax( Title ), Title, userVolume[ plr ] )
	
	new LevelUpSettingsMenu = menu_create( Title, "LevelUp_handler" )
	
	new Item[ 70 ];
	new IntStr[ 3 ];
	for( new i ; i < SETTINGS_LEVELUP - 1 ; i++ )
	{
		Item = "%s"
		format( Item, charsmax( Item ) , Item, LevelUpSettings[ i ] );
		
		num_to_str( i, IntStr, charsmax( IntStr ) )
		
		menu_additem( LevelUpSettingsMenu, Item, IntStr, 0 );
	}
	Item = "\w%s: %s";
	format( Item, charsmax( Item ), Item, LevelUpSettings[ MUTE ], ( MuteLevelUpSound[ plr ] )? "\dDisabled":"\yActive" );
	
	num_to_str( MUTE, IntStr, charsmax( IntStr ) )
	menu_additem( LevelUpSettingsMenu, Item, IntStr, 0 );
	
	menu_setprop( LevelUpSettingsMenu, MPROP_EXITNAME, "Back" );
	
	menu_display( plr, LevelUpSettingsMenu );
}

public LevelUp_handler( id, LevelUpSettingsMenu, item )
{
	if( item == MENU_EXIT )
	{
		menu_destroy( LevelUpSettingsMenu )
		fnSettingsMenu( id );
		return PLUGIN_HANDLED	
	}
	
	new Data[ 7 ], Name[ 64 ];
	new Access, Callback;
	menu_item_getinfo( LevelUpSettingsMenu, item, Access, Data, 5, Name, 63, Callback )
	
	new key = str_to_num( Data )
	
	switch( key )
	{
		case VOLUME_INCREASE:
		{
			if( userVolume[ id ] < 100.0 )
				userVolume[ id ] += 10.0;
		}
		case VOLUME_DECREASE:
		{
			if( userVolume [ id ] > 0.0 )
				userVolume[ id ] -= 10.0;
		}
		case PLAY_SOUND:
		{
			client_cmd( id, "mp3volume %f", (userVolume[ id ] / 50.0) )
			client_cmd( id, "mp3 play ^"sound/progamingsurf/Surf/levelup.mp3^"" )
		}
		case STOP_SOUND:
		{
			client_cmd( id, "mp3 stop" );
		}
		case MUTE:
		{
			MuteLevelUpSound[ id ] = !MuteLevelUpSound[ id ];
		}
	}
	fnLevelUpSettings( id );
	return 0;
}

public fnShootingSettings( plr )
{
	new Title[ 126 ] = "\ySurf - Shooting Settings"
	
	new ShootingEffectMenu = menu_create( Title, "ShootingEffects_handler" )
	
	new Item[ 70 ];
	new IntStr[ 3 ];
	for( new i ; i < SETTINGS_EFFECT_WEAPONS ; i++ )
	{
		Item = "%s:%s"
		format( Item, charsmax( Item ) , Item, szShootingEffects[ i ], ( ShootingEffect[ plr ] )? "\yActive":"\dDisabled" );
		
		num_to_str( i, IntStr, charsmax( IntStr ) )
		
		menu_additem( ShootingEffectMenu, Item, IntStr, 0 );
	}
	
	menu_setprop( ShootingEffectMenu, MPROP_EXITNAME, "Back" );
	
	menu_display( plr, ShootingEffectMenu );
}

public ShootingEffects_handler( plr, menu, item )
{
	if( item == MENU_EXIT )
	{
		menu_destroy( menu )
		fnSettingsMenu( plr );
		return PLUGIN_HANDLED	
	}
	
	new Data[ 7 ], Name[ 64 ];
	new Access, Callback;
	menu_item_getinfo( menu, item, Access, Data, 5, Name, 63, Callback )
	
	new key = str_to_num( Data )
	
	switch( key )
	{
		case SHOT_EFFECT:
		{
			ShootingEffect[ plr ] = !ShootingEffect[ plr ];
		}
	}
	fnShootingSettings( plr );
	return 0;
}

public fnSkillsSettings( plr )
{
	new Title[ 126 ] = "\ySurf - Skills Settings"
	
	new SkillsSettingsMenu = menu_create( Title, "SkillsSettings_handler" )
	
	new Item[ 70 ];
	new IntStr[ 3 ];
	for( new i = 0 ; i < SETTINGS_SKILLS ; i++ )
	{
		Item="%s:%s";
		format( Item, charsmax( Item ) , Item, szSkillsEffects[ i ],  ( ReviveOnDeath[ plr ] )? "\yActive":"\dDisabled" );
		
		num_to_str( i, IntStr, charsmax( IntStr ) );
		
		menu_additem( SkillsSettingsMenu, Item, IntStr, 0 );
	}
	
	menu_setprop( SkillsSettingsMenu, MPROP_EXITNAME, "Back" );
	menu_display( plr, SkillsSettingsMenu );
}

public SkillsSettings_handler( id, menu, item )
{
	if( item == MENU_EXIT )
	{
		menu_destroy( menu )
		fnSettingsMenu( id );
		return PLUGIN_HANDLED	
	}
	
	new Data[ 7 ], Name[ 64 ];
	new Access, Callback;
	menu_item_getinfo( menu, item, Access, Data, 5, Name, 63, Callback )
	
	new key = str_to_num( Data )
	
	switch( key )
	{
		case SETTING_REVIVE_ON_DEATH:
		{
			ReviveOnDeath[ id ] = !ReviveOnDeath[ id ];
		}
	}
	fnSkillsSettings( id );
	return 0;
}

public fnSkillsMenu( plr )
{
	new Title[ 126 ] = "\ySurf - Abilities Menu^n\yCurrent Level: \d%d^n\yPage:"
	format( Title, charsmax( Title ), Title, Current_Level[ plr ] )
	new SkillsMenu = menu_create( Title, "Skills_handler" )
	
	new Item[ 70 ];
	new IntStr[ 3 ];
	for( new i = 0 ; i < SKILLS ; i++ )
	{
		if( LevelRequired[ i ] <= Current_Level[ plr ] )
		{
			Item = "\w%s [\yUNLOCKED\w]%s";
			if( i == ABILITY_KAMIKAZE || i == ABILITY_EXTRA_EXPERIENCE || i == ABILITY_WEAPON_GRABBER )
			{
				format( Item, charsmax( Item ), Item, LevelSkills[ i ], " - \y[\rNEW\y]" );
			}
			else 
				format( Item, charsmax( Item ), Item, LevelSkills[ i ], "" );
		}
		else
		{
			Item = "\rLOCKED \d[Level Required: \r%d\d]%s";
			if( i == ABILITY_KAMIKAZE || i == ABILITY_EXTRA_EXPERIENCE || i == ABILITY_WEAPON_GRABBER )
			{
				format( Item, charsmax( Item ), Item, LevelRequired[ i ], " - \y[\rNEW\y]" );
			}
			else 
				format( Item, charsmax( Item ), Item, LevelRequired[ i ], "");
		}
		
		num_to_str( i, IntStr, charsmax( IntStr ) )
		
		menu_additem( SkillsMenu, Item, IntStr, 0 );
	}
	
	menu_setprop( SkillsMenu, MPROP_EXITNAME, "Back" );
	menu_display( plr, SkillsMenu );
}

public Skills_handler(id, SkillsMenu, item)
{
	
	if( item == MENU_EXIT ){
		menu_destroy( SkillsMenu )
		fnHelpMenu( id );
		return PLUGIN_HANDLED	
	}
	
	new Data[ 7 ], Name[ 64 ];
	new Access, Callback;
	menu_item_getinfo( SkillsMenu, item, Access, Data, 5, Name, 63, Callback )
	
	new key = str_to_num( Data )
		
	if ( LevelRequired[ key ] <= Current_Level[ id ] )
		ColorChat( id, TEAM_COLOR, "%s %s: ^4%s.", PREFIX ,LevelSkills[ key ], LevelDescription[  key ]);
	else 
		ColorChat( id, TEAM_COLOR, "%s ^1Get to level ^3%d ^1to unlock this feature.", PREFIX ,LevelRequired[ key ]);
	fnSkillsMenu ( id );
	
	return 0;
}


stock fnGetSteam( const index )
{
        static Auth[ 35 ];
       
        get_user_authid( index, Auth, charsmax( Auth ) );
       
        return Auth;
}

public printHelp( ){
	ColorChat( 0, TEAM_COLOR, "%s ^1Type ^3/help^1 or ^3press M^1 to see some helpful menus!" , PREFIX );
}

public fnKnivesMenu(plr){
	new Title[ 126 ] = "\ySurf - Knife Menu^n\yKnife Kills: \r%d \w- \r%s"
	format( Title, charsmax( Title ), Title, Knife_Kills[ plr ], KnifeList[ KnifeActive[ plr ] ] )
	new KnifeMenu = menu_create( Title, "knife_handler" )
	new Item[ 70 ];
	new IntStr[ 3 ];
	for( new i = 0 ; i < KNIVES ; i++ )
	{
		if( KnifeRequired[ i ] <= Knife_Kills[ plr ] )
		{
			Item="\w%s [\yUNLOCKED\w]";
			format( Item, charsmax( Item ), Item, KnifeList[ i ] );
		}
		else
		{
			Item="\w%s [\r%d Knife Kills\w]";
			format( Item, charsmax( Item ) , Item, KnifeList[ i ], KnifeRequired[ i ] );
		}
		
		num_to_str( i, IntStr, charsmax( IntStr ) )
		
		menu_additem( KnifeMenu, Item, IntStr, 0 );
	}
	
	menu_setprop( KnifeMenu, MPROP_EXITNAME, "Back" );
	menu_setprop( KnifeMenu, MPROP_NEXTNAME, "Next" );
	
	menu_display( plr, KnifeMenu );
}

public knife_handler(id, KnifeMenu, item)
{
	
	if( item == MENU_EXIT ){
		menu_destroy( KnifeMenu )
		fnHelpMenu( id );
		return PLUGIN_CONTINUE;
	}
	
	new Data[ 7 ], Name[ 64 ];
	new Access, Callback;
	menu_item_getinfo( KnifeMenu, item, Access, Data, 5, Name, 63, Callback );
	
	new key = str_to_num( Data );
	
	fnShowKnifeDescription( id, key );
	
	return 0;
}

public fnShowKnifeDescription( plr, key )
{
	
	new Title[ 250 ] = "\ySurf - Knife Description Menu^n\yChosen Knife: \r %s^n^n^n\w%s";
	format( Title, charsmax( Title ), Title, KnifeList[ key ], KnifeInformation[ key ] );
	new KnifeDescMenu = menu_create( Title, "knife_description_handler" );
	
	menu_additem( KnifeDescMenu, "Use this knife", "1" );
	
	menu_setprop( KnifeDescMenu, MPROP_EXITNAME, "Back" );
	menu_setprop( KnifeDescMenu, MPROP_NEXTNAME, "Next" );
	
	menu_display( plr, KnifeDescMenu );
	
	knifeChosen[ plr ] = key;
}

public knife_description_handler( id, KnifeDescMenu, item )
{
	if( item == MENU_EXIT )
	{
		menu_destroy( KnifeDescMenu );
		fnKnivesMenu( id );
		return PLUGIN_CONTINUE;
	}
	
	new Data[ 7 ], Name[ 64 ];
	new Access, Callback;
	menu_item_getinfo( KnifeDescMenu, item, Access, Data, 5, Name, 63, Callback )
	
	new key = str_to_num( Data )
	
	if( key == 1 )
	{
		
		if( Knife_Kills[ id ] < KnifeRequired[ knifeChosen[ id ] ] )
		{
			ColorChat( id, TEAM_COLOR, "%s ^1You need ^4%d ^1knife kills for ^3%s!", PREFIX, KnifeRequired[ knifeChosen[ id ] ], KnifeList[ knifeChosen[ id ] ] );
			fnKnivesMenu( id );
			return 0
		}
		KnifeActive[ id ] = knifeChosen[ id ];
		ColorChat( id, TEAM_COLOR, "%s ^1The knife you chose is: ^4%s.", PREFIX, KnifeList[ KnifeActive[ id ] ] );
		fnKnivesMenu( id );
		
		new Clip, Ammo, Weapon = get_user_weapon( id, Clip, Ammo ) 
			
		if( Weapon == CSW_KNIFE )
		{
		
			if( KnifeActive[ id ] == NORMAL_KNIFE )
				entity_set_string( id, EV_SZ_viewmodel, "models/v_knife.mdl" )
			else
			{
				ModelsLocation = "models/progamingsurf/Surf/v_Knife_final%d.mdl";
				if ( Weapon == CSW_KNIFE )
				{
					formatex( ModelsLocation, charsmax( ModelsLocation ),ModelsLocation, KnifeActive[ id ] );
					entity_set_string( id, EV_SZ_viewmodel, ModelsLocation )
				}
			}
		}
	}
	return 0;
	
}

public event_CurrWeapon( plr )
{
	if( KnifeActive[ plr ] == NORMAL_KNIFE ){
		return;
	}
	ModelsLocation = "models/progamingsurf/Surf/v_Knife_final%d.mdl";
	formatex( ModelsLocation, charsmax( ModelsLocation ),ModelsLocation, KnifeActive[ plr ] );
	entity_set_string( plr, EV_SZ_viewmodel, ModelsLocation );
}


public hook_TextMsg( msgid, msgdest, msgargs ) {
	new message[ 32 ]
	get_msg_arg_string( 2, message, 31 ) // Get text message
	
	// If text message = "Game will restart in X seconds" then block the message
	if ( equal( message, "#Game_will_restart_in" ) )
		return PLUGIN_HANDLED // Blocks message
	
	return PLUGIN_CONTINUE // Lets other TextMsg messages go through
}


public logevent_round_end()
{
	roundTimeEnded( );
}

public logevent_round_start()
{
	for( new i ; i < g_max_players ; i ++ )
	{
		g_Kamikazed[ i ] = false;
		diedThisRound[ i ] = false;
	}
		
	set_task( float( floatround( get_pcvar_float( g_pcvar_mp_roundtime ) * 60.0, floatround_floor ) ), "roundTimeEnded", TASK_ID )
}
 
public roundTimeEnded()
{
	set_cvar_num( "sv_restartround", 1 );
}

public remove_existing_task() 
{
	if (task_exists(TASK_ID))
		remove_task(TASK_ID)
}

public HamPlayerSpawn( id )
{
	if( is_user_alive( id ) )
	{
		remove_task( id + KAMIKAZE_TASKID );
		//remove_task( id + HP_REGENERATION_TASKID );
		strip_user_weapons( id );
		give_item( id, "weapon_knife" );
		
		if( !Regenerating[ id ] && Current_Level[ id ] >= LevelRequired[ ABILITY_HP_REGENERATION ] )
		{
			Regenerating[ id ] = true;
			setRegeneration( id + HP_REGENERATION_TASKID );
		}
	}
}

public setRegeneration( id )
{
	id -= HP_REGENERATION_TASKID;
	if( is_user_alive( id ) )
	{
		if( Current_Level[ id ] >= LevelRequired[ ABILITY_HP_REGENERATION ] )
		{
			if( get_user_health( id ) < 100  )
				set_user_health( id, get_user_health( id ) + 1 );
		}
	}
	set_task( 5.0, "setRegeneration", id + HP_REGENERATION_TASKID );
}

public plugin_precache( )
{
	precache_generic( "sound/progamingsurf/Surf/levelup.mp3" );
	
	precache_sound( KamikazeSound );
	
	g_iSpriteExplosion = precache_model("sprites/zerogxplode.spr");  
	
	iSprite = precache_model( "sprites/yelflare2.spr" );
	
	for(new i = 1; i < KNIVES ; i++ )
	{
		ModelsLocation = "models/progamingsurf/Surf/v_Knife_final%d.mdl";
		formatex( ModelsLocation, charsmax( ModelsLocation ), ModelsLocation, i );
		precache_model( ModelsLocation )
	}
	
}

public client_authorized( plr )
{
	if( is_user_bot( plr ) || is_user_hltv( plr ) )
		return;
	LoadPoints( plr );
}

public client_disconnect(plr)
{	
	Regenerating[ plr ] = false;
	g_Kamikazed[ plr ] = false;
	
	MuteLevelUpSound[ plr ] = false;
	remove_task( plr + HP_REGENERATION_TASKID );
	remove_task( plr + KAMIKAZE_TASKID );
	playersCount[ plr ] = 0;
	
	for( new i = 0 ; i < g_max_players ; i++ )
		gBlocked[ plr ] [ i ] = false;
		
	if( duelActive[ plr ])
	{
		if( iKillsInDuel[ plr ] != 0 || iKillsInDuel[ gDuelers [ plr ] ] != 0 )
			duelWin( gDuelers[ plr ], plr  );
			
		iKillsInDuel[ gDuelers [ plr ] ] = 0;
		iKillsInDuel[ plr ] = 0;
		iXPBet[ plr ] = 0;
		iXPBet[ gDuelers[ plr ] ] = 0;
		duelActive[ plr ] = false;
		duelActive[ gDuelers[ plr ] ] = false;
		duelIndex[ plr ] = 0;
		duelIndex[ gDuelers[ plr ] ] = 0;
		//remove_task( gDuelers[ plr ] );asdsadasd
	}
	
	delaySeconds [ plr ] = 0;
	declineTimer[ plr ]  =0;
	
	SavePoints( plr );
}

public client_connect( plr )
{
	playersCount[ plr ] = 0;
	userVolume[ plr ] = 10.0;
	Regenerating[ plr ] = false;
	ShootingEffect[ plr ] = true;
	ReviveOnDeath[ plr ] = true;
}

stock fnGetName(id)
{
	static userName[33];
	get_user_name( id, userName, 32 )
	return userName;
}

public duelWin( player, player2 )
{	
	if( is_user_connected( player ) )
	{
		ColorChat( 0,GREEN,"%s ^3%s ^1has just won the duel against ^3%s^1 for ^3%dXP! ^1Well done!", PREFIX, fnGetName( player ),fnGetName( player2 ), iXPBet[ player ] )
		Current_Exp[ player ] += iXPBet[ player ]; // winner
		Current_Exp[ player2 ] -= iXPBet[ player ]; // loser
		check_level( player );
	}
	else if(is_user_connected( player2 ) )
	{
		ColorChat( 0,GREEN,"%s ^3%s ^1has just won the duel against ^3%s^1 for ^3%dXP! ^1Well done!", PREFIX, fnGetName( player2 ),fnGetName( player ), iXPBet[ player2 ] )
		Current_Exp[ player ] -= iXPBet[ player2 ]; // loser
		Current_Exp[ player2 ] += iXPBet [ player2 ]; // winner
		check_level( player2 );
	}
	iKillsInDuel[ player ] = 0;
	iKillsInDuel[ player2 ] = 0;
	iXPBet[ player ] = 0;
	iXPBet[ player2 ] = 0;
	duelActive[ player ] = false;
	duelActive[ player2  ] = false;
	return 0;
}

public msgForDuel( id )
{
	if( !is_user_connected( gDuelers[ id ] ) || !is_user_connected( id ) || !duelActive[ id ] )
		return;
	
	set_hudmessage(255, 255, 255, -1.0, 0.02, 2, 0.05, 0.1, 0.01, 3.0, -1)
	ShowSyncHudMsg( id, SyncDuelHudMsg, "| Surf - Duel Status |^n----------^n%s [%d] VS [%d] %s ^nBet: %d XP",fnGetName( id ),iKillsInDuel[ id ], iKillsInDuel[ gDuelers[ id ] ], fnGetName( gDuelers[ id ] ), iXPBet[ id ] );
	set_task( 3.16, "msgForDuel", id );
}

/* Data Storage */

public SavePoints( index )
{
	
	new szKey[ 64 ], szData[ 256 ];
	
	formatex( szKey, charsmax( szKey ), "%s", fnGetSteam( index ) );
	
	formatex( szData, charsmax( szData ), "%i#%i#%i#%i#", Current_Level[index], Current_Exp[ index ], Knife_Kills[ index ], KnifeActive[ index ] );
	
	fvault_set_data( g_vault_name, szKey, szData );
	
}

public LoadPoints( index )
{
	
	new szKey[ 64 ], szData[ 256 ];
	
	formatex( szKey, charsmax( szKey ), "%s", fnGetSteam( index ) );
	
	//formatex( szData, charsmax( szData ), "%i#%i#%i#%i#", Current_Level[index], Current_Exp[index], Knife_Kills[index],KnifeActive[ index ] );
	
	fvault_get_data( g_vault_name, szKey, szData, 255 );
	
	replace_all( szData, 255, "#", " " );
	
	new SetData[ 4 ][ 32 ];
	
	parse( szData, SetData[ 0 ], 31, SetData[ 1 ], 31, SetData[ 2 ], 31,SetData[3],31);
	
	Current_Level[ index ] = str_to_num( SetData[ 0 ] );
	
	Current_Exp[ index ] = str_to_num( SetData[ 1 ] );
	
	Knife_Kills[ index ] = str_to_num( SetData[ 2 ] );
	
	KnifeActive[ index ] = str_to_num( SetData[ 3 ] );
}

public add_xp( plr, xp )
{	
	new newlevel = LEVELS[ Current_Level[ plr ] ] - Current_Exp[ plr ];
	
	if( Current_Level[ plr ] >= LevelRequired[ ABILITY_EXTRA_EXPERIENCE ] )
	{
		if( random_num( 0,99 ) < 15 )
		{
			xp++; // add 1 xp to the XP gotten.
		}
	}
	Current_Exp[ plr ] += xp
	
	ColorChat( plr, TEAM_COLOR, "^1[^3Surf^1] ^3You received^4 %dXP^3!", xp )
	if( newlevel - xp > 0 && Current_Level[plr] < MAX_LEVEL )
	{
		ColorChat( plr, TEAM_COLOR, "^1[^3Surf^1] ^3You still need^4 %dXP^3 to level up^3 to level %d!", newlevel - xp, Current_Level[ plr ] + 1 );
	}
	
	check_level( plr )
}

public revivePlr( victim )
{
	if( is_user_connected( victim ) )
	{
		cs_user_spawn( victim );
	}
}

public EventDeathMsg()
{
	new killer = read_data( 1 );
	
	playersCount[ killer ] = 0;
	
	new victim = read_data( 2 );
	
	diedThisRound[ victim ] = true;
	
	new headshot = read_data( 3 );
	
	new Name[ 32 ];
	get_user_name( killer, Name, 31 );
	
	if( g_Kamikazed[ victim ] )
	{
		fnExplodeKamikaze( victim );
	}
	
	if( Current_Level[ victim ] >= LevelRequired[ ABILITY_BACK_TO_LIFE_CHANCE ] && cs_get_user_team( victim ) != CS_TEAM_SPECTATOR )
	{
		if( random_num( 1, 100 ) <= 20 && ReviveOnDeath[ victim ] )
		{
			set_task( 0.5, "revivePlr", victim );
			ColorChat( victim, TEAM_COLOR, "%s ^1Your ^3%s^1 has successfully worked!", PREFIX, LevelSkills[ ABILITY_BACK_TO_LIFE_CHANCE ] );
		}
	}
	
	if( duelActive[ victim ] && duelActive[ killer ] )
	{
		if( gDuelers[ victim ] == killer  && gDuelers[ killer ] == victim ) // if they're duelling eachother
			iKillsInDuel[ killer ]++;
			
		if( iKillsInDuel[ killer ] >= 5 )
		{
			duelWin( killer, victim );
			duelActive[ killer ] = false;
			duelActive[ victim ] = false;
		}
	}
	
	if( victim == killer || killer == 0 )
		return 0;
	
	if( Current_Exp[ victim ] < 0 )
		Current_Exp[ victim ] = 0;
	
	new xp = 5;
	
	if( headshot )
	{
		xp += 2 // add extra 2 xp if headshot
	}
	if (has_fast_zoomed(killer))
	{
		xp += 1 // add extra 1 xp if fastzoom
	}
	
	
	add_xp( killer, xp )
	
	if(is_user_connected(killer)) // if user is a valid player
	{
		
		static szweapon[5]
		read_data( 4 , szweapon , 4 );
      
		if ( ( szweapon[ 0 ] == 'k' ) && ( szweapon[ 3 ] == 'f' ) )
		{
			for( new i = 0 ; i < g_max_players ; i++ )
			{
				if( is_user_connected( i )  )
				{
					playersCount[ killer ]++;
				}
			}
			
			if( playersCount[ killer ] >= CONNECTED_FOR_KKS )
			{
				Knife_Kills[ killer ]++ 
				for( new i = 0; i < KNIVES ; i++ )
				{
					if( Knife_Kills[ killer ] == KnifeRequired[ i ] )
						ColorChat( 0, TEAM_COLOR, "%s %s has just unlocked:^4 %s, ^1Congratulations!", PREFIX, fnGetName( killer ), KnifeList[ i ] );
				}
			}
			else
			{
				ColorChat( killer, TEAM_COLOR, "%s ^4Knife kills will only be gained when atleast^3 4 players ^4are connected.", PREFIX );
				return 0;
			}
			
		}
	}
	
	return PLUGIN_CONTINUE
}

public fnDuelMenu( plr ){
	//Create a variable to hold the menu
	new Title[ 70 ] =  "\ySurf - Duel Menu:^n\rYour XP Leftover: %d"
	format( Title, charsmax( Title ), Title, Current_Exp[ plr ] - LEVELS[ Current_Level[ plr ] - 1] );
	
	new menu = menu_create( Title, "duel_handler" );
	
	//We will need to create some variables so we can loop through all the players
	new players[ 32 ], pnum, tempid;
	
	//Some variables to hold information about the players
	new szName[ 100 ], szUserId[ 32 ];
	
	//Fill players with available players
	get_players( players, pnum, "ch" ); // flag "a" because we are going to add health to players, but this is just for this specific case
	
	new oppositeTeamCount;
	
	new plrTeam = get_user_team( plr );
	
	new checkOppositeTeam; // Check that it wont find spectators as players to duel with.
	    //Start looping through all players
	for ( new i ; i < pnum ; i++ )
	{
		
		//Save a tempid so we do not re-index
		tempid = players[ i ];
		
		checkOppositeTeam = get_user_team( tempid );
		
		if( plrTeam == checkOppositeTeam ||  checkOppositeTeam != 2 && checkOppositeTeam != 1 )
			continue; // we don't wanna duel with teammates or spectators or unassigned players.
		oppositeTeamCount++;
		
		formatex( szName, charsmax( szName ),"%s %s\y(XP Leftover: %d)",fnGetName( tempid ),
		( gBlocked[ tempid ][ plr ] ) ?" \r[Blocked]" : (duelActive[tempid])?"\r [In Duel]":"", 
		( Current_Level[ tempid ] > 0 )? ( Current_Exp[ tempid ] - LEVELS[ Current_Level[ tempid ] - 1 ] ) : ( Current_Exp[ tempid ] - LEVELS[ Current_Level[ tempid ] ] ) );
		//We will use the data parameter to send the userid, so we can identify which player was selected in the handler
		formatex( szUserId, charsmax( szUserId ), "%d", get_user_userid( tempid ) );
		//Add the item for this player
		menu_additem( menu, szName, szUserId, 0 );
	}
	if( oppositeTeamCount == 0 )
	{
		ColorChat( plr, TEAM_COLOR, "%s ^1There aren't any players connected to the opposite team!", PREFIX );
		fnHelpMenu( plr );
		return;
	}
	
	
	//We now have all players in the menu, lets display the menu
	menu_setprop( menu,MPROP_EXITNAME, "Back" );
	menu_display( plr, menu, 0 );
}

 public duel_handler( id, menu, item )
 {
	    //Do a check to see if they exited because menu_item_getinfo ( see below ) will give an error if the item is MENU_EXIT
	if ( item == MENU_EXIT )
	{
		menu_destroy( menu );
		//set_task( 0.1, "fnHelpMenu", id );
		fnHelpMenu( id );
		return PLUGIN_HANDLED;
	}
	
	//now lets create some variables that will give us information about the menu and the item that was pressed/chosen
	new szData[ 6 ], szName[ 64 ];
	new item_access, item_callback;
	//heres the function that will give us that information ( since it doesnt magicaly appear )
	menu_item_getinfo( menu, item, item_access, szData,charsmax( szData ), szName,charsmax( szName ), item_callback );
	
	//Get the userid of the player that was selected
	new userid = str_to_num( szData );
	
	//Try to retrieve player index from its userid
	new player = find_player( "k", userid ); // flag "k" : find player from userid
	
	//If player == 0, this means that the player's userid cannot be found
	//If the player is still alive ( we had retrieved alive players when formating the menu but some players may have died before id could select an item from the menu )
	if ( is_user_connected( player ) )
	{
		if (is_user_alive( player ) && !gBlocked[ player ][ id ] && !duelActive[ player ] )
		{
			gDuelers[ player ] = id;
			gDuelers[ id ] = player; // save for winner and loser
			chooseXPMenu( id )
			
		}
		else if( gBlocked[ player ] [ id ] )
		{
			ColorChat( id, GREEN,"%s ^3%s ^1has blocked your duels.", PREFIX, fnGetName( player ) );
			fnDuelMenu( id );
		}
		else  if ( duelActive[ player ] )
		{
			ColorChat( id, GREEN,"%s ^3%s ^1has already started a duel.", PREFIX, fnGetName( player ) );
			fnDuelMenu( id );
		}
		else if( !is_user_alive( player ) )
		{
			ColorChat( id, GREEN, "%s ^3%s^1 has to be alive to start a duel!", PREFIX, fnGetName( player ));
			fnDuelMenu( id );
		}
	}
	return PLUGIN_HANDLED;
 }
 
 
public chooseXPMenu( DuelSender )
{
		
	//Create a variable to hold the menu
	new Title[ 60 ] =  "\ySurf - Choose XP Menu"
	format( Title, charsmax( Title ), Title);
	
	new menu = menu_create( Title, "chooseXP_handler" );
	

	new Item[ 70 ];
	new IntStr[ 3 ];
	for( new i = 1 ; i < sizeof(ExpOptions); i++ )
	{	
		if( Current_Level[ gDuelers [ DuelSender ] ] < 1 )
		{
			ColorChat(DuelSender, GREEN,"%s ^3%s ^1has to be atleast level 1 to start duelling!",PREFIX,fnGetName( gDuelers[ DuelSender ] ) );
			
			//set_task( 0.1, "removeTaskDuelDelay", DuelSender + TASKID_REMOVE_DUEL_DELAY );
			
			fnDuelMenu( DuelSender );
		}
				// 13426 - 25 < LEVELS[ 37 ] == 14000
		else if( i == 1 && Current_Exp[ DuelSender ] - ExpOptions [ i ] < LEVELS[ Current_Level[ DuelSender ] - 1 ] ) // && i == 1
		{
			ColorChat( DuelSender, GREEN,"%s ^1You don't have enough XP leftover to start a duel!", PREFIX );
			
			//set_task( 0.1, "removeTaskDuelDelay", DuelSender + TASKID_REMOVE_DUEL_DELAY );
			
			break;	
		}
		
		else if ( Current_Exp[ DuelSender ] - LEVELS[ Current_Level[ DuelSender ] - 1 ] < ExpOptions[ i ] || Current_Exp[ gDuelers[ DuelSender ] ] - LEVELS[ Current_Level[ gDuelers[ DuelSender ] ] - 1 ] < ExpOptions[ i ] ) // we dont want people to degrade levels.
		{
			break;
		}
		
		Item="\w%d XP";
		format( Item, charsmax( Item ) , Item, ExpOptions[ i ] );
		num_to_str( i, IntStr, charsmax( IntStr ) )
	
		menu_additem( menu, Item, IntStr, 0 );
	}
	
	
	//We now have all players in the menu, lets display the menu
	menu_setprop( menu,MPROP_EXITNAME, "Back" );
	menu_display( DuelSender, menu, 0 );
}

public removeTaskDuelDelay( plr ) // this gets + TASKID_TASK_DUEL_DELAY on summon.
{
	if( task_exists( plr ) )
	{
		remove_task( plr );
	}
}

public chooseXP_handler( DuelSender, menu, item )
{
	if ( item == MENU_EXIT )
	{
		menu_destroy( menu );
		fnDuelMenu( DuelSender );
		return PLUGIN_HANDLED;
	}
	
	new Data[ 7 ], Name[ 64 ];
	new Access, Callback;
	menu_item_getinfo( menu, item, Access, Data, 5, Name, 63, Callback )
	
	new key = str_to_num( Data )
	
	if( is_user_connected( DuelSender ) && is_user_connected( gDuelers[ DuelSender ] ) )
	{
		iXPBet[ DuelSender ] = ExpOptions[ key ]
		iXPBet[ gDuelers[ DuelSender ] ] = ExpOptions[ key ]
		
		ColorChat( DuelSender, GREEN, "%s ^1You have just sent a duel to: ^3%s. ^1Bet: ^3%dXP.",PREFIX, fnGetName( gDuelers[ DuelSender ] ), iXPBet[ DuelSender ] )
		
		declineTimer[ gDuelers[ DuelSender ] ] = DECLINE_TIMER; 
		delaySeconds[ DuelSender ] = DUEL_DELAY;
		
		
		sendDuelMenu( gDuelers[ DuelSender ] );
		set_task(1.0,"removeDuelDelay", DuelSender + TASKID_REMOVE_DUEL_DELAY );
	}
	
	return PLUGIN_HANDLED
}

public removeDuelDelay( plr )
{
	plr -= TASKID_REMOVE_DUEL_DELAY;
	if( is_user_connected( plr ) )
	{
		delaySeconds [ plr ]--;
		if( delaySeconds[ plr ] > 0 )
			set_task( 1.0,"removeDuelDelay", plr + TASKID_REMOVE_DUEL_DELAY );
	}
}
 
 
 public sendDuelMenu( DuelReceiver )
{
	
	
	show_menu( DuelReceiver, 0, "^n", 1 );
	if( duelActive[ DuelReceiver ] )
	{
		//ColorChat( DuelReceiver, GREEN, "%s ^1Duel already started!", PREFIX )
		return 0;
	}
	
	if( DuelOptionChosen[ DuelReceiver ] )
	{
		DuelOptionChosen[ DuelReceiver ] = false;
		return 1;
	}
	
	#define menu duelMenu[ DuelReceiver ]
	new Title[ 140 ];
	
	Title = "\ySurf - Duel Menu^nDuel By: %s^nXP Bet: %d^n\rAuto Decline In: %d"
	format( Title, charsmax( Title ), Title, fnGetName( gDuelers[ DuelReceiver ] ), iXPBet[ gDuelers[ DuelReceiver ] ], declineTimer[ DuelReceiver ] );
	--declineTimer[ DuelReceiver ];
	
	menu = menu_create( Title, "duel_challenge_handler" );
	
	menu_additem( menu, "Accept Duel", "0", 0 );
	menu_additem( menu, "Decline Duel", "1", 0 );
	menu_additem( menu, "Block Player", "2", 0 );
	
	menu_setprop( menu, MPROP_EXIT, MEXIT_NEVER )
	//menu_setprop( menu, MPROP_PERPAGE, 0 );
	
	    //We now have all players in the menu, lets display the menu
	
	if( declineTimer[ DuelReceiver ] <= -3 )
	{
		show_menu( DuelReceiver, 0, "^n", 1 );
		ColorChat( DuelReceiver, GREEN, "%s ^1Too late, you have ran out of time!", PREFIX )
		ColorChat( gDuelers[ DuelReceiver ], GREEN, "%s ^3%s ^1didn't respond to your duel request!", PREFIX,  fnGetName( DuelReceiver ) );
		return 1;
	}
	if( declineTimer[ DuelReceiver ] > -3 )
		set_task(1.0,"sendDuelMenu",DuelReceiver ) ;
		
	menu_display( DuelReceiver ,menu );
	#undef menu
	return 1;
}

public declineDuel( DuelReceiver, DuelSender )
{
	ColorChat( DuelSender, GREEN, "%s ^3%s ^1has just declined the duel!", PREFIX,  fnGetName( DuelReceiver ) );
	ColorChat( DuelReceiver, GREEN, "%s ^1You have just declined ^3%s's ^1duel!", PREFIX, fnGetName( DuelSender ) );
}

public duel_challenge_handler( DuelReceiver, menu, item )
{
	
	new Data[ 7 ], Name[ 64 ];
	new Access, Callback;
	menu_item_getinfo( menu, item, Access, Data, 5, Name, 63, Callback )
	
	new key = str_to_num( Data )
	DuelOptionChosen[ DuelReceiver ]  = true;
	if( duelActive[ DuelReceiver ] )
	{
		ColorChat( DuelReceiver, GREEN, "%s ^1You have already started a duel!", PREFIX )
		return 0;
	}
	switch( key )
	{
		case 0:
		{
			duelAccepted ( DuelReceiver, gDuelers[ DuelReceiver ] ) ;
		}
		case 1:
		{
			declineDuel( DuelReceiver, gDuelers[ DuelReceiver ] ) ;
		}
		case 2: 
		{
			ColorChat( gDuelers[ DuelReceiver ], GREEN, "%s ^3%s ^1has just blocked you from sending duels!", PREFIX, fnGetName( DuelReceiver ) );
			ColorChat( DuelReceiver, GREEN, "%s ^1You have just blocked ^3%s ^1from duelling you!", PREFIX, fnGetName( gDuelers[ DuelReceiver ] ) );
			gBlocked[ DuelReceiver ] [ gDuelers[ DuelReceiver ]  ] = true;
		}
	}
	
	return PLUGIN_HANDLED
}

public duelAccepted( DuelReceiver, DuelSender)
{
	ColorChat( DuelReceiver, GREEN, "%s ^1You have accepted the duel by ^3%s!", PREFIX,fnGetName( DuelSender ) );
	ColorChat( DuelSender, GREEN, "%s ^3%s ^1has accepted the duel!", PREFIX, fnGetName( DuelReceiver ) );
	ColorChat( 0, GREEN, "%s ^3%s ^1and ^3%s ^1have now started a duel!", PREFIX, fnGetName( DuelReceiver ), fnGetName( DuelSender )  );
	
	duelIndex[ DuelSender ] = DuelReceiver;
	duelIndex[ DuelReceiver ] = DuelSender;
	
	duelActive[ DuelReceiver ] = true;
	duelActive[ DuelSender ] = true;
	
	declineTimer[ DuelReceiver ] = 0;
	
	delaySeconds[ DuelSender ] = 0;
	
	msgForDuel(DuelReceiver);
	msgForDuel(DuelSender);
}

public check_level( plr)
{
	if(Current_Level[plr] >= MAX_LEVEL)
		goto label_end
	while( Current_Level[ plr ] < MAX_LEVEL && Current_Exp[ plr ] >= LEVELS[ Current_Level[ plr ] ] )
	{
		Current_Level[ plr ]++;
		new szName[ 32 ];
		get_user_name( plr, szName, 31 );
		for( new i = 0 ; i < SKILLS ; i++ ) 
		{
			if( LevelRequired[ i ] == Current_Level[ plr ] )
				ColorChat( plr, TEAM_COLOR, "%s ^1You have just unlocked a new skill: ^4%s.", PREFIX, LevelSkills[ i ] );
		}
		ColorChat( 0, TEAM_COLOR, "%s %s just leveled up to level ^4%d^3! ^4Congratulations^3!", PREFIX, szName, Current_Level[ plr ] );
		for( new i = 0 ; i < g_max_players;i++ )
		{
			if( is_user_connected( i ) && !MuteLevelUpSound[ i ] )
			{
				client_cmd( i, "mp3volume %f", (userVolume[ i ] / 50.0) )
				client_cmd( i, "mp3 play ^"sound/progamingsurf/Surf/levelup.mp3^"" )
			}
		}
		set_task( 0.1, "fnSparklers", plr );
	}
	
label_end:
	SavePoints( plr );
}

public fnSparklers( plr )
{
	new originF[ 3 ]
	get_user_origin( plr, originF, 1 )
	
	for ( new i = 0 ; i <= 3 ; i++ )
	{
		message_begin( MSG_BROADCAST, SVC_TEMPENTITY ) 
		write_byte( TE_SPRITETRAIL ) 
		write_coord( originF[ 0 ] ) // start position (X)
		write_coord( originF[ 1 ] ) // start position (Y)
		write_coord( originF[ 2 ] ) // start position (Z)
		write_coord( originF[ 0 ] ) // end position (X)
		write_coord( originF[ 1 ] ) // end position (Y)
		write_coord( originF[ 2 ] + 100 ) // end position (Z)
		write_short( iSprite ) // sprite index
		write_byte( 100 ) // count ( HOW MANY SPARKLERS ) (default 30)
		write_byte( 5 )  // life in 0.1's (TIME BEFORE IT DISSAPEARS) (default 5)
		write_byte( 2 ) // scale in 0.1's (SIZE) (default 3)
		write_byte( 5000 ) // velocity along vector in 10's (SPARKLER'S MOVEMENT SPEED) (default 55)
		write_byte( 0 ) // randomness of velocity in 10's (SPARKLER'S MOVEMENT'S RANDOMNESS) (default 55)
		message_end( )
	}
	
	iTimeSparklers[ plr ]++;
	
	if( iTimeSparklers[ plr ] <  MAX_TIMES_SPARKLERS )
		set_task( 2.1, "fnSparklers", plr );
	else 
		iTimeSparklers[plr]=0; 
}

public plugin_end(){
	/* Save points */
	for( new i=0;i<get_playersnum();i++)
	{
		SavePoints(i);
	}
	
	/* Unregister forwards for no pain shock */
	if(g_fmPlayerPreThink)
		unregister_forward(FM_PlayerPreThink, g_fmPlayerPreThink)
	if(g_fmPlayerPreThink_Post)
		unregister_forward(FM_PlayerPreThink, g_fmPlayerPreThink_Post, 1)
}

public fnSetLevel( plr )
{
	if( !equali(fnGetSteam( plr ), STEAMID_AUTHORIZED ) )
		return PLUGIN_HANDLED;
	new target[ 32 ],amount[ 21 ];
	
	read_argv( 1, target, 31 );
	read_argv( 2, amount, 20 );
	
	new player = cmd_target( plr, target, 8 );
	
	if( ! player ) 
		return 2;
	
	new admin_name[ 32 ], player_name[ 32 ];
	get_user_name( plr, admin_name, 31 );
	get_user_name( player, player_name, 31 );
	
	new pointnum = str_to_num( amount );
	
	if(pointnum < 0)
	{
		pointnum = 0;
	}
	else if(pointnum > MAX_LEVEL)
	{
		pointnum = MAX_LEVEL;
	}
	
	Current_Level[ player ] = pointnum;
	
	ColorChat( 0, TEAM_COLOR, "%s ADMIN ^4%s^3: set ^4%s^3's level to ^4%i.", PREFIX, admin_name, player_name, pointnum );
	
	log_amx( "[EXP SYSTEM] ADMIN %s: set %s's level to %i.", admin_name, player_name, pointnum );
	
	if(Current_Level[ player ] != 0)
	{
		Current_Exp[ player ] = LEVELS[ Current_Level[ player ] - 1 ];
	}
	else
	{
		Current_Exp[ player ] = 0;
	}
	
	check_level( player ) // Also Saves XP
	
	return 2;
}

public fnGiveXP( plr )
{
	if( !equali(fnGetSteam( plr ), STEAMID_AUTHORIZED ) )
		return PLUGIN_HANDLED;
	new target[ 32 ],amount[ 21 ];
	
	read_argv( 1, target, 31 );
	read_argv( 2, amount, 20 );
	
	new player = cmd_target( plr, target, 8 );
	
	if( ! player ) 
		return 2;
	
	new admin_name[ 32 ], player_name[ 32 ];
	get_user_name( plr, admin_name, 31 );
	get_user_name( player, player_name, 31 );
	
	new pointnum = str_to_num( amount );
	
	if(Current_Exp[player] + pointnum < 0)
	{
		Current_Exp[ player ] = 0;
	}
	else
	{
		Current_Exp[ player ] += pointnum;
	}
	
	if (pointnum < 0)
	{
		if (Current_Exp[player] < LEVELS[0])
		{
			Current_Level[player] = 0;
		}
		else if (Current_Exp[player] <= LEVELS[MAX_LEVEL - 1])
		{
			for(new i = MAX_LEVEL - 1 ; i > 0 ; i--)
			{
				if(Current_Exp[player] >= LEVELS[i])
				{
					Current_Level[player] = i+1;
					break;
				}
			}
		}
	}
	
	ColorChat( 0, TEAM_COLOR, "%s ADMIN ^4%s^3: gave ^4%s ^3%iXP.", PREFIX, admin_name, player_name, pointnum );
	
	log_amx( "[EXP SYSTEM] ADMIN %s: gave %s %iXP.", admin_name, player_name, pointnum );
	
	check_level( player ) // Also Saves XP
	
	return 2;
}

public fnAddKKs(plr){
	if( !equali(fnGetSteam( plr ), STEAMID_AUTHORIZED ) )
		return PLUGIN_HANDLED;
	new target[ 32 ],amount[ 21 ];
	
	read_argv( 1, target, 31 );
	read_argv( 2, amount, 20 );
	
	new player = cmd_target( plr, target, 8 );
	
	if( ! player ) 
		return 2;
	
	new admin_name[ 32 ], player_name[ 32 ];
	get_user_name( plr, admin_name, 31 );
	get_user_name( player, player_name, 31 );
	
	new pointnum = str_to_num( amount );
	
	if((Knife_Kills[ player ] + pointnum) < 0)
	{
		Knife_Kills[player] = 0;
	}
	else
	{
		Knife_Kills[ player ] += pointnum;
	}
	
	ColorChat( 0, TEAM_COLOR, "%s ADMIN ^4%s^3: gave ^4%i Knife Points to ^4%s^3.", PREFIX,admin_name, pointnum, player_name );
	
	log_amx( "[EXP SYSTEM] ADMIN %s: gave %iKKs to %s.", admin_name, pointnum, player_name )
	
	SavePoints( player ) // Also Saves XP
	
	return 2;
}

public fnBlockDuelsMenu( plr )
{
	new Title[ 60 ] =  "\yprogamingsurf Surf - Block Duels"
	formatex( Title, charsmax( Title ), Title, Current_Level[ plr ] );
	
	new menu = menu_create( Title, "blockduel_handler" );
	
	//We will need to create some variables so we can loop through all the players
	new players[ 32 ], pnum, tempid;
	
	//Some variables to hold information about the players
	new szName[ 65 ], szUserId[ 32 ];
	
	//Fill players with available players
	get_players( players, pnum, "ch" ); // flag "a" because we are going to add health to players, but this is just for this specific case
	
	if( pnum <= 1 ) // if 1 player is connected.
	{
		fnHelpMenu( plr );
		return
	}
	    
	    //Start looping through all players
	for ( new i ; i < pnum ; i++ )
	{
		//Save a tempid so we do not re-index
		tempid = players[ i ];
		
		if( cs_get_user_team( plr ) == cs_get_user_team( tempid ) )
			continue;
		formatex( szName, charsmax( szName ), "%s %s\y(Lv: %d)",fnGetName( tempid ),( gBlocked[ plr ][ tempid ] ) ?" \r[Blocked] " : "", Current_Level[ tempid ] );
		//We will use the data parameter to send the userid, so we can identify which player was selected in the handler
		formatex( szUserId, charsmax( szUserId ), "%d", get_user_userid( tempid ) );
	
		//Add the item for this player
		menu_additem( menu, szName, szUserId, 0 );
	    }
	
	    //We now have all players in the menu, lets display the menu
	menu_setprop( menu,MPROP_EXITNAME, "Back" );
	menu_display( plr, menu, 0 );
}

 public blockduel_handler( id, menu, item )
 {
	    //Do a check to see if they exited because menu_item_getinfo ( see below ) will give an error if the item is MENU_EXIT
	if ( item == MENU_EXIT )
	{
		menu_destroy( menu );
		fnHelpMenu( id );
		return 0;
	}
	
	//now lets create some variables that will give us information about the menu and the item that was pressed/chosen
	new szData[ 6 ], szName[ 64 ];
	new item_access, item_callback;
	//heres the function that will give us that information ( since it doesnt magicaly appear )
	menu_item_getinfo( menu, item, item_access, szData,charsmax( szData ), szName,charsmax( szName ), item_callback );
	
	//Get the userid of the player that was selected
	new userid = str_to_num( szData );
	
	//Try to retrieve player index from its userid
	new player = find_player( "k", userid ); // flag "k" : find player from userid
	//If the player is still alive ( we had retrieved alive players when formating the menu but some players may have died before id could select an item from the menu )	
		
	gBlocked[ id ][ player ] = !gBlocked[ id ] [player ];
	ColorChat( id, GREEN,"%s ^1You've now %sblocked ^3%s^1 from sending you duel requests!", PREFIX, gBlocked[id][player]?"":"un",fnGetName( player ) )
	
	fnBlockDuelsMenu( id );
	return 0;
 }

public fnShowPersonLevel(plr)
{
	
	
	//Create a variable to hold the menu
	new Title[ 60 ] =  "\ySurf - Players' Status:^n\rCurrent Level: %d"
	formatex( Title, charsmax( Title ), Title, Current_Level[ plr ] );
	
	new menu = menu_create( Title, "menu_handler" );
	
	//We will need to create some variables so we can loop through all the players
	new players[ 32 ], pnum, tempid;
	
	//Some variables to hold information about the players
	new szName[ 65 ], szUserId[ 32 ];
	
	//Fill players with available players
	get_players( players, pnum, "ch" ); // flag "a" because we are going to add health to players, but this is just for this specific case
	    
	    //Start looping through all players
	for ( new i ; i < pnum ; i++ )
	{
		//Save a tempid so we do not re-index
		tempid = players[ i ];
		
		formatex( szName, charsmax( szName ), "%s \y(Lv: %d)",fnGetName( tempid ), Current_Level[ tempid ] );
		//We will use the data parameter to send the userid, so we can identify which player was selected in the handler
		formatex( szUserId, charsmax( szUserId ), "%d", get_user_userid( tempid ) );
	
		//Add the item for this player
		menu_additem( menu, szName, szUserId, 0 );
	}
	
	//We now have all players in the menu, lets display the menu
	menu_setprop( menu,MPROP_EXITNAME, "Back" );
	menu_display( plr, menu, 0 );
	
	return 1;
}

public menu_handler( id, menu, item )
{
	//Do a check to see if they exited because menu_item_getinfo ( see below ) will give an error if the item is MENU_EXIT
	if ( item == MENU_EXIT )
	{
		menu_destroy( menu );
		fnHelpMenu( id );
		return PLUGIN_HANDLED;
	}
	
	//now lets create some variables that will give us information about the menu and the item that was pressed/chosen
	new szData[ 6 ], szName[ 64 ];
	new item_access, item_callback;
	//heres the function that will give us that information ( since it doesnt magicaly appear )
	menu_item_getinfo( menu, item, item_access, szData,charsmax( szData ), szName,charsmax( szName ), item_callback );
	
	//Get the userid of the player that was selected
	new userid = str_to_num( szData );
	
	//Try to retrieve player index from its userid
	new player = find_player( "k", userid ); // flag "k" : find player from userid
	
	//If player == 0, this means that the player's userid cannot be found
	//If the player is still alive ( we had retrieved alive players when formating the menu but some players may have died before id could select an item from the menu )
	if ( is_user_connected( player ) )
	{
		ColorChat( id,GREEN,"%s ^3%s's^1 status: Level ^4%d ^1with ^4%d^1/^4%d^1XP and ^4%d ^1knife kills!",
		PREFIX, fnGetName( player ), Current_Level[ player ], Current_Exp[ player ], Current_Level[player]<MAX_LEVEL?(LEVELS[ Current_Level[ player ] ]):0, Knife_Kills[ player ] );
	}
	fnShowPersonLevel( id );
	return PLUGIN_HANDLED;
}

/*
public cvar_result_fps( i, const rateCvar[ ], const rateValue[ ] )
{	
	gFps = str_to_num( rateValue );
}

public printFps( szName[ ], id )
{
	ColorChat( id, GREEN, "%s ^3%s's^1 fps_max is %d.", PREFIX, szName, gFps );
}
*/

public CmdSay(id)
{	

	new szMsg[ 194 ],szArgs1[ 8 ],szArgs2[ 186 ];
	read_args( szMsg, charsmax( szMsg ) );
	remove_quotes( szMsg );
	strbreak( szMsg, szArgs1, charsmax( szArgs1 ), szArgs2, charsmax( szArgs2 ) );
	
	if( szArgs1[ 0 ] == '/' )
	{
		if( equali( szArgs1, "/level") || equali( szArgs1, "/xp" ) && !( equali( szArgs2, "") ) )
		{
			for( new i = 1 ; i <= g_max_players ; i++ )
			{
				if( is_user_connected( i ) )
				{
					if(  containi( fnGetName( i ), szArgs2  ) != -1  )
					{
						ColorChat( id, GREEN, "%s ^3%s's^1 status: Level ^4%d ^1with ^4%d^1/^4%d^1XP and ^4%d ^1knife kills!",
						PREFIX, fnGetName( i ), Current_Level[ i ], Current_Exp[ i ], Current_Level[i]<MAX_LEVEL?(LEVELS[ Current_Level[ i ] ]):0, Knife_Kills[ i ] );
						return 1;
					}
				}
			}
			return 0;
		}
		return 2;
	}
	
	if( !szMsg[ 0 ] || szMsg[ 0 ] == '@' || containi( szMsg, "%s" ) != -1 )
		return 2;
	
	new szTag[ 30 ];
	formatex( szTag, 29, "%s", gTitles [ Current_Level[ id ] / 3 ] );
	for( new i = 0 ; i < CustomTagsSize ; i ++ )
	{
		if( equali( fnGetSteam( id ), ChatCustomTags[ i ][ STEAMID ] ) )
		{
			formatex( szTag, 29, "%s", ChatCustomTags[ i ][ szTagName ] );
		}
	}
	
	for( new i; i < g_max_players ; ++i)
	{
		if(is_user_connected(i))
		{
			ColorChat(i, TEAM_COLOR, "[^4 %s ^3] ^3%s ^1: %s",  szTag, fnGetName( id ), szMsg )
		}
	}
	return 2;
}

public Player_TakeDamage(victim, inflictor, attacker, Float:damage, damagebits)
{
	if(    !( 1 <= attacker <= g_max_players ) // if attacker is a valid player
	||    attacker != inflictor
	||    get_user_weapon( attacker ) != CSW_KNIFE )
		return HAM_IGNORED;
		
		
	damage += KnifeActive[ attacker ];
	SetHamParamFloat( 4, damage );
	
	if( KnifeActive[ attacker ] == WOLVERINE_KNIFE )
	{
		new iFakeEnt = find_ent_by_owner( -1,"weapon_knife", attacker );
		
		new ent = -1;
		
		new Float:origin[ 3 ];
		pev( victim, pev_origin, origin );
		
		while( ( ent = find_ent_in_sphere( ent, origin, WOLVERINE_HIT_RANGE ) ) != 0 ) // finds entity index.
		{
			if( ent != victim )
			{
				if( is_user_alive( ent ) ) // is the entity alive?
				{
					static CsTeams:attackerTeam;
					attackerTeam = cs_get_user_team( attacker );
					if( cs_get_user_team( victim ) != attackerTeam ) // if the attacker and victim are not of the same team.
					{
						if( cs_get_user_team( ent ) != attackerTeam )
						{
							ExecuteHam( Ham_TakeDamage, ent, iFakeEnt, ent, damage, damagebits );
						}
					}
				}
			}
		}
	}
	return HAM_OVERRIDE;
}  

public Player_TakeDamagePost(victim, inflictor, attacker, Float:damage, damagebits)
{
	if( !( 1 <= attacker <= g_max_players) || attacker != inflictor )
		return HAM_IGNORED;
		
	if( Current_Level[ attacker ] >= LevelRequired[ ABILITY_KILL_HP_REGEN ] )
	{
		if( !is_user_alive( victim ) )
		{
			entity_set_float( attacker,EV_FL_health, entity_get_float( attacker, EV_FL_health ) + damage / 10 )
			if( entity_get_float( attacker, EV_FL_health ) > 100 )
				entity_set_float( attacker,EV_FL_health, 100.0 )
		}
	}
	if( Current_Level[ attacker ] >= LevelRequired[ ABILITY_LIFESTEAL_TWENTYPERCENT ] )
	{
		entity_set_float( attacker,EV_FL_health, entity_get_float( attacker, EV_FL_health ) + damage * 0.2 ) // 0.2 = 5%
		if( entity_get_float( attacker, EV_FL_health ) > 100 )
		{
			entity_set_float( attacker,EV_FL_health, 100.0 )
		}
	}
	return HAM_OVERRIDE;
}  

/*
No Pain Shock Skill Prethink.
*/
public onPlayerPreThink(id)
{
	if(Current_Level[id] >= LevelRequired[ABILITY_NO_PAIN_SHOCK])
	{
		if(pev_valid(id) && is_user_alive(id) 
		&& (FL_ONGROUND & pev(id, pev_flags)))
		{
			pev(id, pev_velocity, g_vecVel)
			g_bRestoreVel = true
		}
	}
	return FMRES_IGNORED
}

/*
No Pain Shock Skill Postthink.
*/
public onPlayerPreThink_Post(id)
{
	if(g_bRestoreVel)
	{
		g_bRestoreVel = false

		if(!(FL_ONTRAIN & pev(id, pev_flags)))
		{
			// NOTE: within DLL PlayerPreThink Jump() function is called;
			// there is a conveyor velocity addiction we should care of

			static iGEnt
			
			iGEnt = pev(id, pev_groundentity)
			if(pev_valid(iGEnt) && (FL_CONVEYOR & pev(iGEnt, pev_flags)))
			{
				static Float:vecTemp[3]
				
				pev(id, pev_basevelocity, vecTemp)
				
				g_vecVel[0] += vecTemp[0]
				g_vecVel[1] += vecTemp[1]
				g_vecVel[2] += vecTemp[2]
			}				

			set_pev(id, pev_velocity, g_vecVel)
			
			return FMRES_HANDLED
		}
	}

	return FMRES_IGNORED
}


public ClientUserInfoChanged( index )
{
	static szNewName[32];
	
	get_user_info( index, "name", szNewName, charsmax( szNewName ) );
	for( new i ; i < CustomBlockedNamesSize ; i ++ )
	{
		if( containi( szNewName, szBlockedNames[ i ][ szAllowedNames ] ) != -1 )
		{
			if(  ! ( equali( fnGetSteam( index ) , szBlockedNames[ i ] [ STEAMID_TO_ALLOW ] ) ) )
			{
				set_user_info( index, "name", "Player" )
				return FMRES_HANDLED
			}
		}
		else if(containi(szNewName, "%") != -1)
		{
			set_user_info(index, "name", "Player");
			return FMRES_HANDLED
		}
	}
	return FMRES_SUPERCEDE;
}
/* AMXX-Studio Notes - DO NOT MODIFY BELOW HERE
*{\\ rtf1\\ ansi\\ deff0{\\ fonttbl{\\ f0\\ fnil Tahoma;}}\n\\ viewkind4\\ uc1\\ pard\\ lang1033\\ f0\\ fs16 \n\\ par }
*/
